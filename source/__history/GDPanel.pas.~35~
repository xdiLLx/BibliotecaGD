unit GDPanel;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls;

type
  TResizeOptions = class(TPersistent)
  private
    FCanResize: Boolean;
    FMinWidth: Integer;
    FMinHeight: Integer;
  public
    constructor Create;
  published
    property CanResize: Boolean read FCanResize write FCanResize default False;
    property MinWidth: Integer read FMinWidth write FMinWidth default 100;
    property MinHeight: Integer read FMinHeight write FMinHeight default 100;
  end;

type
  TBorders = (bdNone, bdLeft, bdRight, bdTop, bdBottom);

type
  TGDPanel = class(TPanel)
  private
    FRadius: Integer;
    FMouseDown: Boolean;
    FMousePoint: TPoint;
    FResizeOptions: TResizeOptions;
    FResizingBorder: TBorders;
    procedure SetRadius(const Value: Integer);
    procedure SetResizeOptions(const Value: TResizeOptions);
  protected
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState;
      X, Y: Integer); override;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState;
      X, Y: Integer); override;
    procedure Resize; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Radius: Integer read FRadius write SetRadius;
    property ResizeOptions: TResizeOptions read FResizeOptions
      write SetResizeOptions;
  end;

procedure Register;

implementation

procedure Register;
begin
  RegisterComponents('Biblioteca GD', [TGDPanel]);
end;

{ TGDPanel }

constructor TGDPanel.Create(AOwner: TComponent);
begin
  inherited;
  BevelOuter := bvNone;
  BorderStyle := bsNone;
  DoubleBuffered := True;
  ParentBackground := False;
  FRadius := 15;
  FResizeOptions := TResizeOptions.Create;
end;

destructor TGDPanel.Destroy;
begin
  FResizeOptions.Free;
  inherited;
end;

procedure TGDPanel.SetRadius(const Value: Integer);
begin
  if FRadius <> Value then
  begin
    FRadius := Value;
    Invalidate;  // Force the control to be repainted
  end;
end;

procedure TGDPanel.SetResizeOptions(const Value: TResizeOptions);
begin
  FResizeOptions.Assign(Value);
end;

procedure TGDPanel.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
const
  BORDER_SIZE = 10;
begin
  inherited;
  if (Button = mbLeft) and (FResizeOptions.CanResize) then
  begin
    if (Y <= BORDER_SIZE) then
      FResizingBorder := bdTop
    else if (Y >= Height - BORDER_SIZE) then
      FResizingBorder := bdBottom
    else if (X <= BORDER_SIZE) then
      FResizingBorder := bdLeft
    else if (X >= Width - BORDER_SIZE) then
      FResizingBorder := bdRight
    else
      FResizingBorder := bdNone;

    if FResizingBorder <> bdNone then
    begin
      FMouseDown := True;
      FMousePoint := Point(X, Y);
    end;
  end;
end;

procedure TGDPanel.MouseMove(Shift: TShiftState; X, Y: Integer);
var
  NewWidth, NewHeight, NewLeft, NewTop: Integer;
begin
  inherited;
  if FMouseDown and FResizeOptions.CanResize then
  begin
    case FResizingBorder of
      bdLeft:
        begin
          NewLeft := Self.Left + X - FMousePoint.X;
          NewWidth := Self.Width - X + FMousePoint.X;
          if NewWidth >= FResizeOptions.MinWidth then
          begin
            Self.Left := NewLeft;
            Self.Width := NewWidth;
            FMousePoint := Point(X, Y); // Moved inside the if statement
          end;
        end;
      bdRight:
        begin
          NewWidth := Self.Width + X - FMousePoint.X;
          if NewWidth >= FResizeOptions.MinWidth then
          begin
            Self.Width := NewWidth;
            FMousePoint := Point(X, Y); // Moved inside the if statement
          end;
        end;
      bdTop:
        begin
          NewTop := Self.Top + Y - FMousePoint.Y;
          NewHeight := Self.Height - Y + FMousePoint.Y;
          if NewHeight >= FResizeOptions.MinHeight then
          begin
            Self.Top := NewTop;
            Self.Height := NewHeight;
            FMousePoint := Point(X, Y); // Moved inside the if statement
          end;
        end;
      bdBottom:
        begin
          NewHeight := Self.Height + Y - FMousePoint.Y;
          if NewHeight >= FResizeOptions.MinHeight then
          begin
            Self.Height := NewHeight;
            FMousePoint := Point(X, Y); // Moved inside the if statement
          end;
        end;
    end;
  end;
end;

procedure TGDPanel.MouseUp(Button: TMouseButton; Shift: TShiftState;
  X, Y: Integer);
begin
  inherited;
  FMouseDown := False;
end;

procedure TGDPanel.Paint;
var
  R: TRect;
  Bitmap: TBitmap;
begin
  R := ClientRect;

  Bitmap := TBitmap.Create;
  try
    Bitmap.SetSize(Width, Height);
    Bitmap.Canvas.Pen.Style := psClear;
    Bitmap.Canvas.Brush.Color := Color;
    Bitmap.Canvas.RoundRect(R.Left, R.Top, R.Right, R.Bottom, FRadius, FRadius);

    Canvas.StretchDraw(R, Bitmap);
  finally
    Bitmap.Free;
  end;
end;

{ TResizeOptions }

constructor TResizeOptions.Create;
begin
  inherited;
  FCanResize := False;
  FMinWidth := 100;
  FMinHeight := 100;
end;

end.
