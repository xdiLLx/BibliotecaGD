unit GDPanel;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls;

type
  TGDPanel = class(TPanel)
  private
    FRadius: Integer;
    FMouseDown: Boolean;
    FMousePoint: TPoint;
    FCanResize: Boolean;
    FMinWidth: Integer;
    FMinHeight: Integer;
    procedure SetRadius(const Value: Integer);
    procedure SetCanResize(const Value: Boolean);
    procedure SetMinWidth(const Value: Integer);
    procedure SetMinHeight(const Value: Integer);

  protected
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState;
      X, Y: Integer); override;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState;
      X, Y: Integer); override;
    procedure Resize;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Radius: Integer read FRadius write SetRadius;
    property CanResize: Boolean read FCanResize write SetCanResize;
    property MinWidth: Integer read FMinWidth write SetMinWidth;
    property MinHeight: Integer read FMinHeight write SetMinHeight;
  end;

procedure Register;

implementation

procedure Register;
begin
  RegisterComponents('Biblioteca GD', [TGDPanel]);
end;

{ TGDPanel }

constructor TGDPanel.Create(AOwner: TComponent);
begin
  inherited;
  BevelOuter := bvNone;
  BorderStyle := bsNone;
  FRadius := 15;
end;

procedure TGDPanel.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
const
  BORDER_SIZE = 10;
begin
  inherited;
  if (Button = mbLeft) and (FCanResize) then
  begin
    if (X <= BORDER_SIZE) or (X >= Width - BORDER_SIZE) or
       (Y <= BORDER_SIZE) or (Y >= Height - BORDER_SIZE) then
    begin
      FMouseDown := True;
      FMousePoint := Point(X, Y);
    end;
  end;
end;

procedure TGDPanel.MouseMove(Shift: TShiftState; X, Y: Integer);
var
  NewWidth, NewHeight: Integer;
begin
  inherited;
  if FMouseDown and FCanResize then
  begin
    NewWidth := Self.Width + (X - FMousePoint.X);
    NewHeight := Self.Height + (Y - FMousePoint.Y);
    if NewWidth >= FMinWidth then
      Self.Width := NewWidth;
    if NewHeight >= FMinHeight then
      Self.Height := NewHeight;
    FMousePoint := Point(X, Y);
  end;
end;

procedure TGDPanel.MouseUp(Button: TMouseButton; Shift: TShiftState;
  X, Y: Integer);
begin
  inherited;
  FMouseDown := False;
end;

procedure TGDPanel.Paint;
var
  R: TRect;
begin
  R := ClientRect;
  Canvas.Pen.Style := psClear;
  Canvas.Brush.Color := Color;
  Canvas.RoundRect(R.Left, R.Top, R.Right, R.Bottom, FRadius, FRadius);
end;

procedure TGDPanel.Resize;
var
  Region: HRGN;
begin
  inherited;
  Region := CreateRoundRectRgn(0, 0, Width, Height, FRadius, FRadius);
  SetWindowRgn(Handle, Region, True);
  DeleteObject(Region); // Libera a região após usá-la
end;

procedure TGDPanel.SetRadius(const Value: Integer);
begin
  if FRadius <> Value then
  begin
    FRadius := Value;
    Invalidate;
  end;
end;

procedure TGDPanel.SetCanResize(const Value: Boolean);
begin
  if FCanResize <> Value then
  begin
    FCanResize := Value;
  end;
end;

procedure TGDPanel.SetMinWidth(const Value: Integer);
begin
  if FMinWidth <> Value then
  begin
    FMinWidth := Value;
    if Width < FMinWidth then
      Width := FMinWidth;
  end;
end;

procedure TGDPanel.SetMinHeight(const Value: Integer);
begin
  if FMinHeight <> Value then
  begin
    FMinHeight := Value;
    if Height < FMinHeight then
      Height := FMinHeight;
  end;
end;
end.
