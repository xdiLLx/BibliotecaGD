unit GDPanel;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls;

type
  TResizeOptions = class(TPersistent)
  private
    FCanResize: Boolean;
    FMinWidth: Integer;
    FMinHeight: Integer;
  public
    constructor Create;
  published
    property CanResize: Boolean read FCanResize write FCanResize default False;
    property MinWidth: Integer read FMinWidth write FMinWidth default 100;
    property MinHeight: Integer read FMinHeight write FMinHeight default 100;
  end;

type
  TBorders = (bdNone, bdLeft, bdRight, bdTop, bdBottom);

type
  TGDPanelAlign = (paNone, paLeft, paTop, paRight, paBottom, paClient,
    paCenter);

type
  TGDPanel = class(TPanel)
  private
    FRadius: Integer;
    FMouseDown: Boolean;
    FMousePoint: TPoint;
    FParent: TWinControl;
    FResizing: Boolean;
    FResizeOptions: TResizeOptions;
    FResizingBorder: TBorders;
    FGDPanelAlign: TGDPanelAlign;
    FOriginalWidth: Integer;
    FOriginalHeight: Integer;
    procedure SetGDPanelAlign(Value: TGDPanelAlign);
    procedure SetRadius(const Value: Integer);
    procedure SetResizeOptions(const Value: TResizeOptions);
    procedure SetBounds(ALeft, ATop, AWidth, AHeight: Integer);
  protected
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState;
      X, Y: Integer); override;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState;
      X, Y: Integer); override;
    procedure Resize; override;
    procedure ParentResized(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Radius: Integer read FRadius write SetRadius;
    property ResizeOptions: TResizeOptions read FResizeOptions
      write SetResizeOptions;
    property AlignPanel: TGDPanelAlign read FGDPanelAlign write SetGDPanelAlign;
    property Align stored False;
  end;

procedure Register;

implementation

procedure Register;
begin
  RegisterComponents('Biblioteca GD', [TGDPanel]);
end;

{ TGDPanel }

constructor TGDPanel.Create(AOwner: TComponent);
begin
  inherited;
  BevelOuter := bvNone;
  BorderStyle := bsNone;
  DoubleBuffered := True;
  ParentBackground := False;
  FRadius := 15;
  FResizeOptions := TResizeOptions.Create;
  FOriginalWidth := Width;
  FOriginalHeight := Height;

  if Assigned(AOwner) and (AOwner is TWinControl) then
  begin
    FParent := TWinControl(AOwner);
  end;
end;

destructor TGDPanel.Destroy;
begin
  FResizeOptions.Free;
  inherited;
end;

procedure TGDPanel.Resize;
var
  Region: HRGN;
begin
  inherited;
  Region := CreateRoundRectRgn(0, 0, Width, Height, FRadius, FRadius);
  SetWindowRgn(Handle, Region, True);
  DeleteObject(Region); // Libera a região após usá-la
  if FGDPanelAlign = paCenter then
  begin
    Left := (Parent.ClientWidth - FOriginalWidth) div 2;
    Top := (Parent.ClientHeight - FOriginalHeight) div 2;
    Width := FOriginalWidth;
    Height := FOriginalHeight;
  end;
end;

procedure TGDPanel.SetBounds(ALeft, ATop, AWidth, AHeight: Integer);
begin
  inherited SetBounds(ALeft, ATop, AWidth, AHeight);
  if (csDesigning in ComponentState) and (FGDPanelAlign = paCenter) and
    Assigned(Parent) then
  begin
    inherited SetBounds((Parent.ClientWidth - Width) div 2,
      (Parent.ClientHeight - Height) div 2, Width, Height);
  end;
end;

procedure TGDPanel.SetGDPanelAlign(Value: TGDPanelAlign);
begin
  if FGDPanelAlign <> Value then
  begin
    FGDPanelAlign := Value;

    case Value of
      paNone:
        begin
          inherited Align := alNone;
          Anchors := [];
        end;
      paLeft:
        begin
          inherited Align := alLeft;
          Anchors := [];
        end;
      paTop:
        begin
          inherited Align := alTop;
          Anchors := [];
        end;
      paRight:
        begin
          inherited Align := alRight;
          Anchors := [];
        end;
      paBottom:
        begin
          inherited Align := alBottom;
          Anchors := [];
        end;
      paClient:
        begin
          inherited Align := alClient;
          Anchors := [];
        end;
      paCenter:
        begin
          inherited Align := alNone;
          // Anchors := [akLeft, akTop, akRight, akBottom];
          // Ative as ancoras em todos os lados
          if FResizingBorder = bdNone then
          begin
            Left := (Parent.ClientWidth - FOriginalWidth) div 2;
            Top := (Parent.ClientHeight - FOriginalHeight) div 2;
           // Width := FOriginalWidth;
            //Height := FOriginalHeight;
          end
          else
          begin
            Left := (Parent.ClientWidth - FOriginalWidth) div 2;
            Top := (Parent.ClientHeight - FOriginalHeight) div 2;
          end;
        end;
    end;
  end;
end;

procedure TGDPanel.SetRadius(const Value: Integer);
begin
  if FRadius <> Value then
  begin
    FRadius := Value;
    Invalidate; // Force the control to be repainted
  end;
end;

procedure TGDPanel.SetResizeOptions(const Value: TResizeOptions);
begin
  FResizeOptions.Assign(Value);
end;

procedure TGDPanel.MouseDown(Button: TMouseButton; Shift: TShiftState;
  X, Y: Integer);
const
  BORDER_SIZE = 10;
begin
  inherited;
  if (Button = mbLeft) and (FResizeOptions.CanResize) then
  begin
    if (Y <= BORDER_SIZE) then
      FResizingBorder := bdTop
    else if (Y >= Height - BORDER_SIZE) then
      FResizingBorder := bdBottom
    else if (X <= BORDER_SIZE) then
      FResizingBorder := bdLeft
    else if (X >= Width - BORDER_SIZE) then
      FResizingBorder := bdRight
    else
      FResizingBorder := bdNone;

    if FResizingBorder <> bdNone then
    begin
      FMouseDown := True;
      FMousePoint := Point(X, Y);
    end;

  end;
end;

procedure TGDPanel.MouseMove(Shift: TShiftState; X, Y: Integer);
var
  deltaX, deltaY: Integer;
begin
  inherited;
  if FMouseDown and FResizeOptions.CanResize then
  begin
    FResizing := True;
    deltaX := X - FMousePoint.X;
    deltaY := Y - FMousePoint.Y;

    case FResizingBorder of
      bdLeft:
        if Width - deltaX >= FResizeOptions.MinWidth then
        begin
          if FGDPanelAlign = paCenter then
            SetBounds(Left + deltaX div 2, Top, Width - deltaX, Height);
        end;

      bdRight:
        if Width + deltaX >= FResizeOptions.MinWidth then
          SetBounds(Left, Top, Width + deltaX, Height);

      bdTop:
        if Height - deltaY >= FResizeOptions.MinHeight then
        begin
          if FGDPanelAlign = paCenter then
            SetBounds(Left, Top + deltaY div 2, Width, Height - deltaY);
        end;

      bdBottom:
        if Height + deltaY >= FResizeOptions.MinHeight then
          SetBounds(Left, Top, Width, Height + deltaY);
    end;
    if (FGDPanelAlign in [paCenter]) and Assigned(FParent) then
    begin
      Left := (FParent.ClientWidth - Width) div 2;
      Top := (FParent.ClientHeight - Height) div 2;
    end;
    FMousePoint := Point(X, Y);
    FResizing := False;
  end;
end;

procedure TGDPanel.MouseUp(Button: TMouseButton; Shift: TShiftState;
  X, Y: Integer);
begin
  inherited;
  FMouseDown := False;

  if (FGDPanelAlign = paCenter) and Assigned(Parent) then
  begin
    Left := (Parent.ClientWidth - Width) div 2;
    Top := (Parent.ClientHeight - Height) div 2;
  end;
  if FResizingBorder <> bdNone then
  begin
    FOriginalWidth := Width;
    FOriginalHeight := Height;
  end;
end;

procedure TGDPanel.Paint;
var
  R: TRect;
  Bitmap: TBitmap;
begin
  R := ClientRect;

  Bitmap := TBitmap.Create;
  try
    Bitmap.SetSize(Width, Height);
    Bitmap.Canvas.Pen.Style := psClear;
    Bitmap.Canvas.Brush.Color := Color;
    Bitmap.Canvas.RoundRect(R.Left, R.Top, R.Right, R.Bottom, FRadius, FRadius);

    Canvas.StretchDraw(R, Bitmap);
  finally
    Bitmap.Free;
  end;
end;

procedure TGDPanel.ParentResized(Sender: TObject);
begin
  if (FGDPanelAlign = paCenter) then
  begin
    Left := (FParent.ClientWidth - Width) div 2;
    Top := (FParent.ClientHeight - Height) div 2;
  end;
end;

{ TResizeOptions }

constructor TResizeOptions.Create;
begin
  inherited;
  FCanResize := False;
  FMinWidth := 100;
  FMinHeight := 100;
end;

end.
